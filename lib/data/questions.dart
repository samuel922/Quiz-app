import 'package:quiz_app/models/quiz_question.dart';

const questions = [
  QuizQuestion(
    id: 'widgets',
    question: 'What are the fundamental building blocks of every Flutter UI?',
    possibleAnswers: [
      'Widgets',
      'Handlers',
      'Bundles',
      'XML layouts',
    ],
    category: 'Fundamentals',
    difficulty: QuestionDifficulty.easy,
    fact: 'Every visible element in Flutter is a widget, even layout wrappers.',
  ),
  QuizQuestion(
    id: 'composition',
    question: 'How are complex Flutter interfaces typically composed?',
    possibleAnswers: [
      'By combining smaller widgets',
      'By inheriting from a template view',
      'By editing a storyboard file',
      'By configuring native builders',
    ],
    category: 'Architecture',
    difficulty: QuestionDifficulty.easy,
    fact: 'Composition keeps widgets tiny and makes them easy to reason about.',
  ),
  QuizQuestion(
    id: 'stateful-widget',
    question: 'Why would you reach for a StatefulWidget over a StatelessWidget?',
    possibleAnswers: [
      'You need to react to user input or async events',
      'You want to share data with other widgets',
      'You need better performance',
      'You want to avoid build() entirely',
    ],
    category: 'State',
    difficulty: QuestionDifficulty.medium,
    fact: 'StatefulWidgets hold mutable State objects that can trigger rebuilds.',
  ),
  QuizQuestion(
    id: 'stateless',
    question: 'What happens when you update a field inside a StatelessWidget?',
    possibleAnswers: [
      'Nothing, the UI does not rebuild automatically',
      'The widget rebuilds immediately',
      'Only child widgets rebuild',
      'The Flutter engine hot-reloads the change',
    ],
    category: 'State',
    difficulty: QuestionDifficulty.medium,
    fact: 'StatelessWidgets are immutable; to refresh UI you must rebuild from above.',
  ),
  QuizQuestion(
    id: 'setstate',
    question: 'Which API should you call to trigger a rebuild inside a StatefulWidget?',
    possibleAnswers: [
      'setState()',
      'updateUI()',
      'notifyListeners()',
      'recompose()',
    ],
    category: 'State',
    difficulty: QuestionDifficulty.easy,
    fact: 'setState() marks the widget dirty and schedules the next frame.',
  ),
  QuizQuestion(
    id: 'lifecycles',
    question: 'Which lifecycle method fires once when the State object is inserted?',
    possibleAnswers: [
      'initState',
      'build',
      'didUpdateWidget',
      'dispose',
    ],
    category: 'Lifecycle',
    difficulty: QuestionDifficulty.medium,
    fact: 'initState is ideal for starting controllers or one-time listeners.',
  ),
  QuizQuestion(
    id: 'inherited',
    question: 'What is the main benefit of using an InheritedWidget or Provider?',
    possibleAnswers: [
      'Propagating data efficiently down the widget tree',
      'Avoiding the need for themes',
      'Rendering widgets faster than setState',
      'Auto-saving to local storage',
    ],
    category: 'Architecture',
    difficulty: QuestionDifficulty.hard,
    fact: 'InheritedWidgets notify dependents only when the exposed data changes.',
  ),
  QuizQuestion(
    id: 'layout',
    question: 'Which widget helps align children vertically with equal spacing?',
    possibleAnswers: [
      'Column with MainAxisAlignment.spaceBetween',
      'Row with CrossAxisAlignment.stretch',
      'Stack with Alignment.center',
      'Align with FractionalOffset',
    ],
    category: 'Layout',
    difficulty: QuestionDifficulty.easy,
    fact: 'Columns combined with Expanded widgets make responsive layouts trivial.',
  ),
  QuizQuestion(
    id: 'async',
    question: 'How should you handle long-running work without blocking the UI thread?',
    possibleAnswers: [
      'Use Future/async APIs or compute isolates',
      'Invoke sleep() inside build',
      'Run a while loop until done',
      'Schedule work inside initState synchronously',
    ],
    category: 'Performance',
    difficulty: QuestionDifficulty.medium,
    fact: 'Flutter runs on a single UI thread; heavy work must move off-thread.',
  ),
  QuizQuestion(
    id: 'themes',
    question: 'What is the easiest way to share colors and text styles app-wide?',
    possibleAnswers: [
      'Configure ThemeData on MaterialApp',
      'Wrap every widget in a Container',
      'Customize each widget manually',
      'Edit the Android manifest',
    ],
    category: 'Styling',
    difficulty: QuestionDifficulty.easy,
    fact: 'ThemeData propagates through the widget tree and can be overridden locally.',
  ),
];